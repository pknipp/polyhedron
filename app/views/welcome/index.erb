<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <body>
    <div style="padding:20px">
      <div style="text-align:center">
        <h3>Three-dimensional shape generation and rendering (WIP)</h3>
      </div>
      <div>
        <b>Overview:</b> This endpoint enables the user to generate and render a 3-dimensional structure that consists of vertices and edges. The user may also rotate this structure in order to view from any perspective.
      </div>
      <br/>
      <div>
        <b>Instructions:</b> There are two different ways that the user can create a 3-dimensional structure for rendering.
        <ol>
          <li>
            <a href="https://en.wikipedia.org/wiki/Simplicial_polytope">simplicial polyhedron</a>, ie any 3-dimensional shape whose faces are triangular:<br/>
            After <tt>...herokuapp.com</tt> above the user should type <tt>/edges/&lt;triangle&gt;/&lt;tetrahedra&gt;</tt>, where the <tt>&lt;triangle&gt;</tt> path fragment describes the first triangle, and the <tt>&lt;tetrahedra&gt;</tt> path fragment describes the tetrahedra that are built atop that triangle, as follows
            <ul>
              <li>
                <b>First fragment:</b> This is a six-item comma-separated list that characterizes the first triangular face of the polyhedron.  The first three items are vertex names, and the last three are lengths of the edges connecting the 1st and 2nd vertices, the 2nd and 3rd vertices, and the 1st and 3rd vertices respectively.
              </li>
              <li>
                <b>Second fragment (optional):</b>  This is a comma-separated list of seven-element tuples, each of which characterizes a tetrahedron that defines a vertex added to this polyhedron.  Each of the tuple's first three items is the name of an existing vertex of the polyhedron, and the fourth is the name of the vertex added here. The last three items are the lengths of the three edges that connect the existing vertices with the added vertex.  Note that there are two such tetrahedra defined by these numbers.  The convention here is to take the tetrahedron such that the added vertex is <i>above</i> the triangle formed by the existing vertices, when the existing ones are viewed clockwise.
              </li>
            </ul>
          </li>
          <li>
            (WIP) Collection of vertices and edges:<br/>
            After <tt>...herokuapp.com</tt> above the user should type <tt>/points/&lt;vertices&gt;/&lt;edges&gt;</tt>, where the <tt>&lt;vertices&gt;</tt> path fragment describes the vertices of the shape, and the <tt>&lt;edges&gt;</tt> path fragment specifies which pairs of vertices should be connected by a line segment, as follows
            <ul>
              <li>
                <b>First fragment:</b> This is a comma-separated list of five-item tuples,
                each describing a vertex.  For each tuple the first item is the vertex's key, the second (optional) item provides a human-readable label to use when rendering, and the last three are the vertex's Cartesian coordinates.
              </li>
              <li>
                <b>Second fragment:</b> This is a comma-separated list of two-item tuples.  Each tuple contains the keys for each pair of vertices that should be connected by line segments.
              </li>
            </ul>
          </li>
        </ol>
        Notes:
        <br/> This will only return html (not json), even for the case of errors.
        <br/> Guidelines for urls:
        <ul>
          <li> The use of whitespace is allowed but discouraged.</li>
          <li> Commas are prohibited except for separating elements in arrays.</li>
          <li> Numbers may be represented in many different ways except that any decimal point should be represented by an asterisk rather than by a period owing to the fact that the latter has a special meaning in a url.</li>
        </ul>
      </div>
      <br/>
      <div>
        <b>Example:</b> <tt>...heroku.com/edges/A,B,C,1,1,1*414/
        (A,B,C,D,1*414,1,1*414),
        (A,D,C,E,1*732,1,1*732),
        (A,E,C,F,2,1,2),
        (A,F,C,G,2*24,1,2*24),
        (A,G,C,H,2*45,1,2*45),
        (A,H,C,I,2*65,1,2*65),
        (A,I,C,J,2*83,1,2*83),
        (A,J,C,K,3,1,3),
        (A,K,C,L,3*16,1,3*16),
        (A,L,C,M,3*32,1,3*32),
        (A,M,C,N,3*46,1,3*46),
        (A,N,C,O,3*61,1,3*61),
        (A,O,C,P,3*74,1,3*74),
        (A,P,C,Q,3*87,1,3*87),
        (A,Q,C,R,4,1,4),
        (A,R,C,S,4*12,1,4*12),
        (A,S,C,T,4*24,1,4*24  ),
        (A,T,C,U,,1,),
        (A,U,C,V,,1,),
        (A,V,C,W,,1,)
        </tt> generates the shell of a 16-chambered nautilus whose outline coincides with the spiral of Theodorus.
      </div>
    </div>




    <div style="text-align:center">
      <h4>Click and drag in order to rotate polyhedron</h4>
      <div>
        <span><b>Perspective:</b></span>
        <label class="radio-inline">
          <input type="radio" name="optradio" checked value="Infinity">None
        </label>
        <label class="radio-inline">
          <input type="radio" name="optradio" value="2">Some
        </label>
        <label class="radio-inline">
          <input type="radio" name="optradio" value="1">Lots
        </label>
      </div>
      <svg id="svg" perspective="Infinity" is-dragging="F" mouse="0,0" width="900" height="900" xmlns="http://www.w3.org/2000/svg">
        <!-- Asymmetric tetrahedron -->
        <g class="vertices">
          <text x="90" y="370" z="330" dx="-5" dy=".3em">A</text>
          <text x="810" y="370" z="330" dx="-5" dy=".3em">B</text>
          <text x="810" y="670" z="330" dx="-5" dy=".3em">C</text>
          <text x="810" y="478" z="570" dx="-5" dy=".3em">D</text>
        </g>
        <g class="edges">
          <line x1="90" y1="370" z1="330" x2="810" y2="670" z2="330"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/>
          <line x1="90" y1="370" z1="330" x2="810" y2="370" z2="330"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/>
          <line x1="810" y1="370" z1="330" x2="810" y2="670" z2="330"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/>
          <line x1="810" y1="478" z1="570" x2="810" y2="670" z2="330"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/>
          <line x1="810" y1="478" z1="570" x2="810" y2="370" z2="330"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/>
          <line x1="810" y1="478" z1="570" x2="90" y2="370" z2="330"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/>
        </g>
        <!-- Chair -->
        <!-- <line x1="300" y1="750" z1="300" x2="300" y2="450" z2="300"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="300" y1="150" z1="300" x2="300" y2="450" z2="300"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="600" y1="750" z1="300" x2="600" y2="450" z2="300"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="600" y1="150" z1="300" x2="600" y2="450" z2="300"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="300" y1="150" z1="300" x2="600" y2="150" z2="300"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="300" y1="450" z1="300" x2="600" y2="450" z2="300"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="300" y1="450" z1="600" x2="600" y2="450" z2="600"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="300" y1="450" z1="300" x2="300" y2="450" z2="600"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="600" y1="450" z1="300" x2="600" y2="450" z2="600"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="300" y1="750" z1="600" x2="300" y2="450" z2="600"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
        <!-- <line x1="600" y1="750" z1="600" x2="600" y2="450" z2="600"  stroke="rgb(50% 50% 50%)" stroke-width="1" pointer-events="visiblePainted"/> -->
      </svg>
    </div>
  </body>
  <script>
    let svg = document.getElementById("svg");
    let lines = Array.from(svg.getElementsByTagName("line"));
    let texts = Array.from(svg.getElementsByTagName("text"));
    let inputs = Array.from(document.getElementsByTagName("input"));
    let origin = 450;
    const setLineAttributes = (line, pair, perspective) => {
      let zAvg = 0;
      pair.forEach((end, j) => {
        let z = end[2];
        zAvg += z;
        for (k = 0; k < 2; k++) {
          end[k] = end[k] * (1 + z / perspective);
        }
        [`x${1 + j}`, `y${1 + j}`, `z${1 + j}`].forEach((dir,k) => line.setAttribute(dir, end[k] + origin));
      });
      zAvg /= 2;
      line.setAttribute("stroke-width", 1 + zAvg / perspective);
      let darkness = `rgb(${(Math.round(100 * (1 - (1 + zAvg / perspective) / 2)) + "% ").repeat(3)})`;
      line.setAttribute("stroke", darkness);
    };
    const setTextAttributes = (text, point, perspective) => {
      for (k = 0; k < 2; k++) {
        point[k] = point[k] * (1 + point[2] / perspective);
      }
      ["x", "y", "z"].forEach((dir,k) => text.setAttribute(dir, point[k] + origin));
    };
    const stopMoving = svg => svg.setAttribute("is-dragging", "F");
    const changePerspective = (svg, lines, texts, checked, perspective) => {
      if (checked) {
        let oldPerspective = Number(svg.getAttribute("perspective") * origin);
        svg.setAttribute("perspective", perspective);
        perspective *= origin;
        lines.forEach(line => {
          let pair = [];
          for (j = 1; j < 3; j++) {
            let end = [`x${j}`, `y${j}`, `z${j}`].map(dir => (Number(line.getAttribute(dir)) - origin));
            [0, 1].forEach(k => {
              end[k] /= (1 + end[2]  / oldPerspective);
            });
            pair.push(end);
          }
          setLineAttributes(line, pair, perspective);
        });
        texts.forEach(text => {
          let point = ["x", "y", "z"].map(dir => (Number(text.getAttribute(dir)) - origin));
          [0, 1].forEach(k => {
            point[k] /= (1 + point[2]  / oldPerspective);
          });
          setTextAttributes(text, point, perspective);
        });
      }
    };
    function throttle(svg, lines, texts, e, interval) {
      // A flag variable to track whether the function is running or not
      let isRunning = false;
      let perspective = Number(svg.getAttribute("perspective")) * origin;
      // Return a function that takes arguments
      return () => {
          // If the function is not running
          if (!isRunning) {
              // Set the flag to true
              isRunning = true;
              let isDragging = svg.getAttribute("is-dragging");
              let mouse = svg.getAttribute("mouse");
              mouse = mouse.split(',').map(val => Number(val));
              if (isDragging === "T") {
                let mouseNew = [e.offsetX, e.offsetY];
                svg.setAttribute("mouse", mouseNew.join(','));
                let dxy = mouseNew.map((newVal, i) => newVal - mouse[i]);
                let thz = -Math.atan2(dxy[0], dxy[1]);
                let cz = Math.cos(thz);
                let sz = Math.sin(thz);
                // Following factor (0.01) makes the UX feel right.
                let thx = 0.02 * Math.sqrt(dxy[0] * dxy[0] + dxy[1] * dxy[1]);
                let cx = Math.cos(thx);
                let sx = Math.sin(thx);
                // Below are rows of a 3x3 rotation matrix obtained as follows:
                // Rotation about z-axis, rotation about x-axis, ending by
                // negation of the original rotation about the z-axis.
                let rotx = [cz * cz + cx * sz * sz, cz * sz * (1 - cx), -sx * sz];
                let roty = [sz * cz * (1 - cx), sz * sz + cx * cz * cz, sx * cz];
                let rotz = [sx * sz, -sx * cz, cx];
                let rots = [rotx, roty, rotz];
                lines.forEach(line => {
                  const pair = [];
                  for (j = 1; j < 3; j++) {
                    let end = [`x${j}`, `y${j}`, `z${j}`].map(dir => (Number(line.getAttribute(dir)) - origin));
                    [0, 1].forEach(k => end[k] /= (1 + end[2] / perspective));
                    let endNew = [];
                    // Implement the rotation transformation.
                    for (const rot of rots) {
                      endNew.push(rot.reduce((val, element, i) => {
                        return val + element * end[i];
                      }, 0));
                    }
                    pair.push(endNew);
                  }
                  setLineAttributes(line, pair, perspective);
                });
                texts.forEach(text => {
                  let point = ["x", "y", "z"].map(dir => (Number(text.getAttribute(dir)) - origin));
                  [0, 1].forEach(k => point[k] /= (1 + point[2] / perspective));
                  let pointNew = [];
                    // Implement the rotation transformation.
                  for (const rot of rots) {
                    pointNew.push(rot.reduce((val, element, i) => {
                      return val + element * point[i];
                    }, 0));
                  }
                  setTextAttributes(text, pointNew, perspective);
                });
              }
              // Set a timer that will reset the flag after the interval
              setTimeout(() => {
                  // Set the flag to false
                  isRunning = false;
              }, interval);
          }
      };
    }
    // document is repainted no more frequently than every 10 ms.
    svg.addEventListener("mousemove", e => throttle(svg, lines, texts, e, 10)());
    svg.addEventListener("mousedown", e => {
      svg.setAttribute("is-dragging", "T");
      svg.setAttribute("mouse", e.offsetX + "," + e.offsetY);
    });
    svg.addEventListener("mouseleave", e => stopMoving(svg));
    svg.addEventListener("mouseup", e => stopMoving(svg));
    inputs.forEach(input => input.addEventListener(
      "change",
      e => changePerspective(svg, lines, texts, input.checked, Number(input.value)),
    ));
  </script>
</html>
